/*******************************************************************
        SYSTEM cipsystem
        Module for PROCESS doorControl
        Filename: doorControl.c
        generated by CIP Tool(R)

        activated code options:
        	C code
        		naming option: channel name prefix
        	enable PENDING_ information
        	incremental build
        	'unsigned char' for delays
*********************************************************************/

/* Include Files */

#include "mDoorControlUnit.h"

/* Process Macro Definitions */

#define SELF status_doorControl.write_access_
#define STATUS (pStatus_doorControl->read_access_)
#define TIME time_
#define canClose() TRTAB_canClose \
	[status_openButton.read_access_.STATE - 1] \
	[status_lightBarrier.read_access_.STATE - 1] != 0

/* Process Enumerations */

enum eMODES_doorControl
	{normal = 1, alarm = 2};

enum eSTATES_doorControl
	{Blocked = 1, Delayed, Done, Opening};

enum eINPULS_doorControl
	{IP_open = 14, IP_doorOpened = 15, IP_released = 17, IP_push = 18, 
	 IP_modeEntry = 19, TIMEUP_ = 20};
	

/* External Declarations */

extern unsigned char time_;
extern struct tTMQE_mDoorControlUnit *tuhead_mDoorControlUnit, *tutail_mDoorControlUnit;
extern struct tCHNOUT_mDoorControlUnit CHNOUT_mDoorControlUnit;
extern struct tTIMING_mDoorControlUnit TIMING_mDoorControlUnit[TIMER_COUNT_];
extern union tSTATUS_alarmToggler status_alarmToggler;
extern union tSTATUS_lightBarrier status_lightBarrier;
extern union tSTATUS_openButton status_openButton;
void fUPDATE_DoorControlSystem (void);
int fPULSE_door (enum eOUTPLS_ name_);
void fSETTIM_mDoorControlUnit (unsigned char *delay_, struct tTMEL_mDoorControlUnit *timer_, struct tTMQE_mDoorControlUnit *timeup_);
void fSTOPTIM_mDoorControlUnit (struct tTMEL_mDoorControlUnit *timer_, struct tTMQE_mDoorControlUnit *timeup_);

/* Global Declarations */

static unsigned char delay_;
struct tPRINST_doorControl IO_doorControl;
union tSTATUS_doorControl status_doorControl;
const union tSTATUS_doorControl *pStatus_doorControl = &status_doorControl;
const int MODTAB_doorControl[2] =       /* [alarmToggler states] */
	{normal, alarm};

const static unsigned char TRTAB_canClose[2][3] =      /* [openButton states][lightBarrier states] */
	{{0, 0, 0},
	{1, 0, 0}};


/* Function Prototypes */

int fPULSE_doorControl (enum eOUTPLS_ name_);
void fINIT_doorControl (void);

/* Input Channel Functions */

int fPULSE_doorControl (enum eOUTPLS_ name_)
{
	switch(name_)
	{
		/* INPULSE open */
	case O20_interrupted:		/* PULSE CAST from PROCESS lightBarrier */
	case O2_pressed:		/* PULSE CAST from PROCESS openButton */
		switch(MODTAB_doorControl[status_alarmToggler.read_access_.STATE - 1])
		{
		case normal:
			switch(status_doorControl.read_access_.STATE)
			{
			case Delayed:
				status_doorControl.write_access_.STATE = Blocked;
				break;
			case Done:
				status_doorControl.write_access_.STATE = Opening;
				fPULSE_door (O6_doorOpen);
				break;
			default:
				break;
			}
			break;
		default:
			break;
		}
		break;
		/* INPULSE doorOpened */
	case O18_opened:		/* PULSE CAST from PROCESS door */
		switch(MODTAB_doorControl[status_alarmToggler.read_access_.STATE - 1])
		{
		case normal:
			switch(status_doorControl.read_access_.STATE)
			{
			case Opening:
				if (canClose())
				{
					delay_ =  2*TICKS_PER_SECOND;	/* DELAY doorOpenDelay */
					status_doorControl.write_access_.STATE = Delayed;
					fSETTIM_mDoorControlUnit(&delay_, 
						&IO_doorControl.timer_, 
						&IO_doorControl.timeup_);
				}
				else
				{
					status_doorControl.write_access_.STATE = Blocked;
				}
				break;
			default:
				break;
			}
			break;
		default:
			break;
		}
		break;
		/* INPULSE released */
	case O20_cleared:		/* PULSE CAST from PROCESS lightBarrier */
		switch(MODTAB_doorControl[status_alarmToggler.read_access_.STATE - 1])
		{
		case normal:
			switch(status_doorControl.read_access_.STATE)
			{
			case Blocked:
				if (canClose())
				{
					delay_ =  2*TICKS_PER_SECOND;	/* DELAY doorOpenDelay */
					status_doorControl.write_access_.STATE = Delayed;
					fSETTIM_mDoorControlUnit(&delay_, 
						&IO_doorControl.timer_, 
						&IO_doorControl.timeup_);
				}
				else
				{
					status_doorControl.write_access_.STATE = Blocked;
				}
				break;
			default:
				break;
			}
			break;
		default:
			break;
		}
		break;
		/* INPULSE modeEntry */
	case O22_on:		/* PULSE CAST from PROCESS alarmToggler */
		switch(MODTAB_doorControl[status_alarmToggler.read_access_.STATE - 1])
		{
		case alarm:
			switch(status_doorControl.read_access_.STATE)
			{
			case Blocked:
				status_doorControl.write_access_.STATE = Done;
				fPULSE_door (O6_doorClose);
				break;
			case Delayed:
				status_doorControl.write_access_.STATE = Done;
				fPULSE_door (O6_doorClose);
				break;
			case Opening:
				status_doorControl.write_access_.STATE = Done;
				fPULSE_door (O6_doorClose);
				break;
			default:
				break;
			}
			break;
		default:
			break;
		}
		break;
	default:
		return 0;
	}
	return 1;
}

/* Timer Functions */

static void fTICK_doorControl (void)
{
	if (IO_doorControl.timer_.set_ &&
		IO_doorControl.timer_.end_ == time_)
	{
		IO_doorControl.timer_.set_ = FALSE;
		--TIMING_mDoorControlUnit[TIMER_doorControl_6].set_;
		if (tuhead_mDoorControlUnit != &IO_doorControl.timeup_ &&
			!IO_doorControl.timeup_.preced_ &&
			!IO_doorControl.timeup_.next_)
		{
			if (!tuhead_mDoorControlUnit)
			{
				tuhead_mDoorControlUnit = tutail_mDoorControlUnit = &IO_doorControl.timeup_;
			}
			else
			{
				tutail_mDoorControlUnit->next_ = &IO_doorControl.timeup_;
				IO_doorControl.timeup_.preced_ = tutail_mDoorControlUnit;
				tutail_mDoorControlUnit = &IO_doorControl.timeup_;
			}
		}
	}			
}

static void fTUHNDL_doorControl(void)
{
	struct tTMQE_mDoorControlUnit *element_ = tuhead_mDoorControlUnit;
	if (tuhead_mDoorControlUnit == tutail_mDoorControlUnit)
	{
		tuhead_mDoorControlUnit = tutail_mDoorControlUnit = 0;
	}
	else 
	{
		tuhead_mDoorControlUnit = element_->next_;
		element_->next_ = 0;
		tuhead_mDoorControlUnit->preced_ = 0;
	}
	switch(MODTAB_doorControl[status_alarmToggler.read_access_.STATE - 1])
	{
	case normal:
		switch(status_doorControl.read_access_.STATE)
		{
		case Delayed:
			status_doorControl.write_access_.STATE = Done;
			fPULSE_door (O6_doorClose);
			break;
		default:
			break;
		}
		break;
	default:
		break;
	}
	fUPDATE_DoorControlSystem (); 
}

/* Process Initialization Function */

void fINIT_doorControl (void)
{
	status_doorControl.write_access_.STATE = Done;
	IO_doorControl.timer_.set_ = FALSE;
	IO_doorControl.timeup_.preced_ = 0;
	IO_doorControl.timeup_.next_ = 0;
	IO_doorControl.timeup_.proctype_ = TIMER_doorControl_6;
	TIMING_mDoorControlUnit[TIMER_doorControl_6].tkhndl_ = fTICK_doorControl;
	TIMING_mDoorControlUnit[TIMER_doorControl_6].tuhndl_ = fTUHNDL_doorControl;
}		

/*********************************************************************
	End of Module for PROCESS doorControl
*********************************************************************/
/* Actifsource ID=[e9267837-2596-11e1-ae2f-a14f3e396de6,79056c7a-4728-11e4-aefa-c3efe9fa99c0,cca6c98c-462e-11e4-8d10-617b527355dd,5bf79245-4729-11e4-aefa-c3efe9fa99c0,790879be-4728-11e4-aefa-c3efe9fa99c0,632d07b4-462f-11e4-8d10-617b527355dd,e3eebc84-7091-11e4-99ab-454e858e60a3,aO09N5UlU23RaKH1NUyNcdl4YWI=] */
