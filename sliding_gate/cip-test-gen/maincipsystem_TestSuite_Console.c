/*********************************************************************
  SYSTEM cipsystem
  IMPLEMENTATION DoorControlSystemImplHost
  Error Header File for CIP MACHINE mDoorControlUnit
  Filename: maincipsystem_TestSuite_Console.c
  generated by CIP Tool(R)
  
  activated code options:
  	C code
  		naming option: channel name prefix
  	enable PENDING_ information
  	incremental build
  	'unsigned char' for delays
*********************************************************************/

/* Begin Protected Region [[include]] */

/* End Protected Region   [[include]] */
#include "sDoorControlUnit.h"
#include "eDoorControlUnit.h"
#include <stdio.h>
#include <string.h>

#define VAR (*var_)

/** Enum to specify the animation mode. */
typedef enum EAnimationMode
{
  eAnimationMode_Undefined,
  eAnimationMode_Manual,
  eAnimationMode_Regressive,
  eAnimationMode_Runner
} T_EAnimationMode;

/** Enum to specify the trace mode. */
typedef enum ETraceMode
{
  eTrace_Disable,
  eTrace_Enable
} T_ETraceMode;

/** Enum variable to specify the animation mode. */
T_EAnimationMode g_eAnimationMode = eAnimationMode_Undefined;

/** Enum variable to specify the trace mode. */
T_ETraceMode g_eTraceMode = eTrace_Disable;

/** Enum for all event messages of this system. */
typedef enum EEventMessage
{
  eEventMessage_Quit = -1,
  eEventMessage_Tick = 0,
  eEventMessage_button1InChannel_press = 1,
  eEventMessage_button1InChannel_release,
  eEventMessage_button2InChannel_press,
  eEventMessage_button2InChannel_release,
  eEventMessage_doorInChannel_doorOpened,
  eEventMessage_doorInChannel_doorClosed,
  eEventMessage_doorInChannel_doorNotClosed,
  eEventMessage_doorInChannel_doorNotOpened,
  eEventMessage_lightBarrierInChannel_interrupted,
  eEventMessage_lightBarrierInChannel_cleared
} T_EEventMessage; 

/** Enum for all action messages of this system. */
typedef enum EActionMessage
{
  eActionMessage_light1OutChannel_on,
  eActionMessage_light1OutChannel_off,
  eActionMessage_light2OutChannel_off,
  eActionMessage_light2OutChannel_on,
  eActionMessage_driveOutChannel_open,
  eActionMessage_driveOutChannel_close,
  eActionMessage_driveOutChannel_stop,
  eActionMessage_lightBarrierOutChannel_on,
  eActionMessage_lightBarrierOutChannel_off,
  eActionMessageCount
} T_EActionMessage; 

/** Enum for all test case. */
typedef enum ETestCase
{
  eTestCase_close_at_beginning,
  eTestCase_open_timeup_close,
  eTestCase_blink_while_closing,
  eTestCase_open_timeup_startClosing,
  eTestCase_open_timeup_close_lightbarrier_interrupt_immediately,
  eTestCase_alarm_when_blocked,
  eTestCase_alarm_while_start_opening,
  eTestCase_open
} T_ETestCase;

/* Checked output message */
const int checkedOutputMessage_close_at_beginning[eActionMessageCount] = {0, 0, 0, 0, 0, 1, 1, 0, 0};
const int checkedOutputMessage_open_timeup_close[eActionMessageCount] = {0, 0, 0, 0, 1, 1, 1, 0, 0};
const int checkedOutputMessage_blink_while_closing[eActionMessageCount] = {1, 1, 0, 0, 0, 0, 0, 0, 0};
const int checkedOutputMessage_open_timeup_startClosing[eActionMessageCount] = {0, 0, 0, 0, 1, 1, 1, 0, 0};
const int checkedOutputMessage_open_timeup_close_lightbarrier_interrupt_immediately[eActionMessageCount] = {0, 0, 0, 0, 1, 1, 1, 0, 0};
const int checkedOutputMessage_alarm_when_blocked[eActionMessageCount] = {0, 0, 0, 0, 1, 1, 1, 0, 0};
const int checkedOutputMessage_alarm_while_start_opening[eActionMessageCount] = {0, 0, 0, 0, 1, 1, 1, 0, 0};
const int checkedOutputMessage_open[eActionMessageCount] = {0, 0, 0, 0, 1, 1, 1, 0, 0};





/** Recorded action message of this system. */
typedef struct SRecordedActionMessage
{
  T_EActionMessage actionMessage;
} T_RecordedActionMessage;

/** Maximum action messages which can be recorded per event message for automatic animation. */
enum {g_nMaxRecordedActionMessageCount = 100};

/** The number of recorded action messages. */
int g_nRecordedActionMessageCount = 0;

/** The number of expected action messages. */
int g_nExpectedActionMessageCount = 0;

/** An array which contains the recorded action messages. */
T_RecordedActionMessage g_eRecordedActionMessage[g_nMaxRecordedActionMessageCount];

/** System Tick. */
int s_nSystemTick = 0;

/* Active Test Case */
T_ETestCase activeTestCase;

/**
 * Checked output message
 */
char isCheckedOutputMessage(T_EActionMessage i_eActionMessage)
{
  switch (activeTestCase)
  {
     case eTestCase_close_at_beginning:
       return checkedOutputMessage_close_at_beginning[i_eActionMessage];
     case eTestCase_open_timeup_close:
       return checkedOutputMessage_open_timeup_close[i_eActionMessage];
     case eTestCase_blink_while_closing:
       return checkedOutputMessage_blink_while_closing[i_eActionMessage];
     case eTestCase_open_timeup_startClosing:
       return checkedOutputMessage_open_timeup_startClosing[i_eActionMessage];
     case eTestCase_open_timeup_close_lightbarrier_interrupt_immediately:
       return checkedOutputMessage_open_timeup_close_lightbarrier_interrupt_immediately[i_eActionMessage];
     case eTestCase_alarm_when_blocked:
       return checkedOutputMessage_alarm_when_blocked[i_eActionMessage];
     case eTestCase_alarm_while_start_opening:
       return checkedOutputMessage_alarm_while_start_opening[i_eActionMessage];
     case eTestCase_open:
       return checkedOutputMessage_open[i_eActionMessage];
     default:
       return 0;
     break;
  }
  return 1;
}

/**
 *  Translates the given action message enum to string.
 *  @param i_eActionMessage The message type to translate.
 *  @return The translated action message or 0 if enum not found.
 */
const char* const translateActionMessage(T_EActionMessage i_eActionMessage)
{
  switch (i_eActionMessage)
  {
    case eActionMessage_light1OutChannel_on:
      return "light1OutChannel.on";
    break;
    case eActionMessage_light1OutChannel_off:
      return "light1OutChannel.off";
    break;
    case eActionMessage_light2OutChannel_off:
      return "light2OutChannel.off";
    break;
    case eActionMessage_light2OutChannel_on:
      return "light2OutChannel.on";
    break;
    case eActionMessage_driveOutChannel_open:
      return "driveOutChannel.open";
    break;
    case eActionMessage_driveOutChannel_close:
      return "driveOutChannel.close";
    break;
    case eActionMessage_driveOutChannel_stop:
      return "driveOutChannel.stop";
    break;
    case eActionMessage_lightBarrierOutChannel_on:
      return "lightBarrierOutChannel.on";
    break;
    case eActionMessage_lightBarrierOutChannel_off:
      return "lightBarrierOutChannel.off";
    break;
    case eActionMessageCount:
      return 0;
    break;
    default:
      return 0;
    break;
  }
  return 0;
}

/**
 *  Check if the Action message has equals data.
 *  @param i_eActionMessage The message type to translate.
 *  @return The action message is equals 1 or 0 if not.
 */
char equalsActionMessageData(T_RecordedActionMessage sActionMessage, T_RecordedActionMessage sRecordedActionMessage)
{
  switch (sRecordedActionMessage.actionMessage)
  {
    case eActionMessage_light1OutChannel_on:
      return 1;
    break;
    case eActionMessage_light1OutChannel_off:
      return 1;
    break;
    case eActionMessage_light2OutChannel_off:
      return 1;
    break;
    case eActionMessage_light2OutChannel_on:
      return 1;
    break;
    case eActionMessage_driveOutChannel_open:
      return 1;
    break;
    case eActionMessage_driveOutChannel_close:
      return 1;
    break;
    case eActionMessage_driveOutChannel_stop:
      return 1;
    break;
    case eActionMessage_lightBarrierOutChannel_on:
      return 1;
    break;
    case eActionMessage_lightBarrierOutChannel_off:
      return 1;
    break;
    case eActionMessageCount:
      return 1;
    break;
    default:
      return 1;
    break;
  }
  return 1;
}

/**
 *  Check if the Action message has equals index.
 *  @param i_eActionMessage The message type to translate.
 *  @return The action message is equals 1 or 0 if not.
 */
char equalsActionMessageIndex(T_RecordedActionMessage sActionMessage, T_RecordedActionMessage sRecordedActionMessage)
{
  switch (sRecordedActionMessage.actionMessage)
  {
    case eActionMessage_light1OutChannel_on:
      return 1;
    break;
    case eActionMessage_light1OutChannel_off:
      return 1;
    break;
    case eActionMessage_light2OutChannel_off:
      return 1;
    break;
    case eActionMessage_light2OutChannel_on:
      return 1;
    break;
    case eActionMessage_driveOutChannel_open:
      return 1;
    break;
    case eActionMessage_driveOutChannel_close:
      return 1;
    break;
    case eActionMessage_driveOutChannel_stop:
      return 1;
    break;
    case eActionMessage_lightBarrierOutChannel_on:
      return 1;
    break;
    case eActionMessage_lightBarrierOutChannel_off:
      return 1;
    break;
    case eActionMessageCount:
      return 1;
    break;
    default:
      return 1;
    break;
  }
  return 1;
}

/**
 *  Records the message action from the cip system.
 *  @param i_eActionMessage The message type to record.
 */
void recordMessageAction(T_RecordedActionMessage sRecordedActionMessage)
{
  if (g_nRecordedActionMessageCount>=g_nMaxRecordedActionMessageCount) {return;}
  g_eRecordedActionMessage[g_nRecordedActionMessageCount++] = sRecordedActionMessage;
}

/**
 *  Asserts the message action from the cip system.
 *  @param i_eActionMessage The action message type to compare.
 *  @param i_pcTestEventGuid The guid of the test event.
 *  @param i_pcActionMessageGuid The guid of the action message to compare.
 *  @return 1 if recoreded and expected message actions are equal. 0 if not.
 *  @warning Previously record message actions with recordMessageAction()
 */
int assertMessageAction(T_RecordedActionMessage sRecordedActionMessage, const char* const i_pcTestEventGuid, const char* const i_pcActionMessageGuid, const char* const i_testCaseName, int checkData)
{
  if (g_nExpectedActionMessageCount >= g_nRecordedActionMessageCount) 
  {
    if (g_eAnimationMode == eAnimationMode_Runner) {
       printf("3891007e-4d40-11e4-9197-0359679bc414.asr: Failure\n");
       printf("TestCase: %s\n", i_testCaseName);
    }
    printf("    ASSERTION FAILED: %s\n",i_pcTestEventGuid);
    printf("    > Expected: ActionMessage #%i = %s %s\n", g_nExpectedActionMessageCount, translateActionMessage(sRecordedActionMessage.actionMessage), i_pcActionMessageGuid);
    printf("    > Recorded: -\n");
    return 0;
  }
  T_RecordedActionMessage sActionMessage = g_eRecordedActionMessage[g_nExpectedActionMessageCount++];
  if (sActionMessage.actionMessage != sRecordedActionMessage.actionMessage)
  {
    if (g_eAnimationMode == eAnimationMode_Runner) {
       printf("3891007e-4d40-11e4-9197-0359679bc414.asr: Failure\n");
       printf("TestCase: %s\n", i_testCaseName);
    }
    printf("    ASSERTION FAILED: %s\n",i_pcTestEventGuid);
    printf("    > Expected: ActionMessage #%i = %s %s\n", g_nExpectedActionMessageCount, translateActionMessage(sRecordedActionMessage.actionMessage), i_pcActionMessageGuid);
    printf("    > Recorded: ActionMessage #%i = %s\n", g_nExpectedActionMessageCount, translateActionMessage(sActionMessage.actionMessage));
    return 0;
  }
  if (!equalsActionMessageIndex(sActionMessage, sRecordedActionMessage)) 
  {
    if (g_eAnimationMode == eAnimationMode_Runner) {
       printf("3891007e-4d40-11e4-9197-0359679bc414.asr: Failure\n");
       printf("TestCase: %s\n", i_testCaseName);
    }
    printf("    ASSERTION FAILED: %s\n",i_pcTestEventGuid);
    printf("    > Expected: ActionMessage index not equals #%i = %s %s\n", g_nExpectedActionMessageCount, translateActionMessage(sRecordedActionMessage.actionMessage), i_pcActionMessageGuid);
    printf("    > Recorded: ActionMessage index not equals #%i = %s\n", g_nExpectedActionMessageCount, translateActionMessage(sActionMessage.actionMessage));
    return 0;
  }
  if (!checkData) return 1;
  if (!equalsActionMessageData(sActionMessage, sRecordedActionMessage)) 
  {
    if (g_eAnimationMode == eAnimationMode_Runner) {
       printf("3891007e-4d40-11e4-9197-0359679bc414.asr: Failure\n");
       printf("TestCase: %s\n", i_testCaseName);
    }
    printf("    ASSERTION FAILED: %s\n",i_pcTestEventGuid);
    printf("    > Expected: ActionMessage data not equals #%i = %s %s\n", g_nExpectedActionMessageCount, translateActionMessage(sRecordedActionMessage.actionMessage), i_pcActionMessageGuid);
    printf("    > Recorded: ActionMessage data not equals #%i = %s\n", g_nExpectedActionMessageCount, translateActionMessage(sActionMessage.actionMessage));
    return 0;
  }
  return 1;
}

/**
 *  Asserts and resets the message action count variable.
 *  @param i_pcTestEventGuid The guid of the test event.
 *  @return 1 if recoreded and expected message action counts are equal. 0 if not.
 */
int assertMessageActionCount(const char* const i_pcTestEventGuid, const char* const i_testCaseName)
{
  int bEqualMessageActionCount = g_nExpectedActionMessageCount == g_nRecordedActionMessageCount;
  if (!bEqualMessageActionCount)
  {
    if (g_eAnimationMode == eAnimationMode_Runner) {
       printf("3891007e-4d40-11e4-9197-0359679bc414.asr: Failure\n");
       printf("TestCase: %s\n", i_testCaseName);
    }
    printf("    ASSERTION FAILED: %s\n",i_pcTestEventGuid);
    printf("    > Expected: -\n");
    for (;g_nExpectedActionMessageCount<g_nRecordedActionMessageCount;++g_nExpectedActionMessageCount)
    {
      printf("    > Recorded: ActionMessage #%i = %s\n", g_nExpectedActionMessageCount+1,translateActionMessage(g_eRecordedActionMessage[g_nExpectedActionMessageCount].actionMessage));
    }
  }
  g_nRecordedActionMessageCount = 0;
  g_nExpectedActionMessageCount = 0;
  return bEqualMessageActionCount;
}

/** 
 *  Sends the message event to the cip system.
 *  @param i_eEventMessage The message type to send.
 *  @param i_bAutoStep Automatically calls STEP_ if 1. Calls STEP_ for all pending events if code option enable_PENDING_Information set.
 *  @return 1 if ok. 0 if failed.
 */
int sendMessageEvent(T_EEventMessage i_eEventMessage, int i_bAutoStep )
{
  switch (i_eEventMessage)
  {
    case eEventMessage_button1InChannel_press:
      if (g_eTraceMode == eTrace_Enable) {printf(" EventMessage: press  \n");}
      IN_button1InChannel_press();
    break;
    case eEventMessage_button1InChannel_release:
      if (g_eTraceMode == eTrace_Enable) {printf(" EventMessage: release  \n");}
      IN_button1InChannel_release();
    break;
    case eEventMessage_button2InChannel_press:
      if (g_eTraceMode == eTrace_Enable) {printf(" EventMessage: press  \n");}
      IN_button2InChannel_press();
    break;
    case eEventMessage_button2InChannel_release:
      if (g_eTraceMode == eTrace_Enable) {printf(" EventMessage: release  \n");}
      IN_button2InChannel_release();
    break;
    case eEventMessage_doorInChannel_doorOpened:
      if (g_eTraceMode == eTrace_Enable) {printf(" EventMessage: doorOpened  \n");}
      IN_doorInChannel_doorOpened();
    break;
    case eEventMessage_doorInChannel_doorClosed:
      if (g_eTraceMode == eTrace_Enable) {printf(" EventMessage: doorClosed  \n");}
      IN_doorInChannel_doorClosed();
    break;
    case eEventMessage_doorInChannel_doorNotClosed:
      if (g_eTraceMode == eTrace_Enable) {printf(" EventMessage: doorNotClosed  \n");}
      IN_doorInChannel_doorNotClosed();
    break;
    case eEventMessage_doorInChannel_doorNotOpened:
      if (g_eTraceMode == eTrace_Enable) {printf(" EventMessage: doorNotOpened  \n");}
      IN_doorInChannel_doorNotOpened();
    break;
    case eEventMessage_lightBarrierInChannel_interrupted:
      if (g_eTraceMode == eTrace_Enable) {printf(" EventMessage: interrupted  \n");}
      IN_lightBarrierInChannel_interrupted();
    break;
    case eEventMessage_lightBarrierInChannel_cleared:
      if (g_eTraceMode == eTrace_Enable) {printf(" EventMessage: cleared  \n");}
      IN_lightBarrierInChannel_cleared();
    break;
    default:
      return 0;
    break;
  }
  if (i_bAutoStep)
  {
    int maxAnyCount = 0;
    while (maxAnyCount < 50 && TRG_PENDING_.ANY_)
    {
      if (g_eTraceMode == eTrace_Enable) {printf(" STEP_\n");}
      TRG_STEP_();
      maxAnyCount++;
    }
    if (maxAnyCount == 50)
    {
      if (g_eTraceMode == eTrace_Enable) {printf("!! AUTO STEP BREAK 50 STEPs !!\n");}
    }
  }
  return 1;
}

/**
 *  Timeup Function forward.
 */
void sendTimeupEvent();

/** 
 *  Sends the tick event to the cip system.
 *  @param i_nTickCount The number of ticks.
 *  @param i_bAutoTimeup Calls TIMEUP_ after each tick if set.
 */
void sendTickEvent(int i_nTickCount, int i_bAutoTimeup)
{
  int nTickCount;
  if (g_eTraceMode == eTrace_Enable) {printf(" START TICK_ #%i\n",s_nSystemTick);}
  for (nTickCount=0;nTickCount<i_nTickCount;++nTickCount)
  {
    s_nSystemTick++;
    TRG_TICK_(); 
    if (i_bAutoTimeup) {TRG_TIMEUP_();}
  }
  if (g_eTraceMode == eTrace_Enable) {printf(" END TICK_ #%i\n",s_nSystemTick);}
}

/** 
 *  Sends the step event to the cip system.
 */
void sendStepEvent()
{
  if (g_eTraceMode == eTrace_Enable) {printf(" STEP_\n");}
  TRG_STEP_();
}

/** 
 *  Sends the chain event to the cip system.
 */
void sendChainEvent()
{
  if (g_eTraceMode == eTrace_Enable) {printf(" CHAIN_\n");}
  TRG_CHAIN_(); 
}

/** 
 *  Sends the timeup event to the cip system.
 */
void sendTimeupEvent()
{
  if (g_eTraceMode == eTrace_Enable) {printf(" TIMEUP_\n");}
  TRG_TIMEUP_(); 
}

/** 
 *  Sends the read event to the cip system.
 */
void sendReadEvent()
{
  if (g_eTraceMode == eTrace_Enable) {printf(" READ_\n");}
  TRG_READ_(); 
}

/** 
 *  Sends the auto event to the cip system.
 */
void sendAutoEvent()
{
  if (g_eTraceMode == eTrace_Enable) {printf(" AUTO_\n");}
  TRG_AUTO_(); 
}

/** 
 *  light1OutChannel.on action message callback (Action Initiation).
 */
void OUT_light1OutChannel_on()
{
  if (g_eTraceMode == eTrace_Enable) {printf("   ActionMessage: light1OutChannel.on \n\n");}
  if (g_eAnimationMode == eAnimationMode_Regressive || g_eAnimationMode == eAnimationMode_Runner) {
    T_RecordedActionMessage sRecorded;
    sRecorded.actionMessage = eActionMessage_light1OutChannel_on;
    if (!isCheckedOutputMessage(sRecorded.actionMessage)) return;
    recordMessageAction(sRecorded);
  }
}

/** 
 *  light1OutChannel.off action message callback (Action Initiation).
 */
void OUT_light1OutChannel_off()
{
  if (g_eTraceMode == eTrace_Enable) {printf("   ActionMessage: light1OutChannel.off \n\n");}
  if (g_eAnimationMode == eAnimationMode_Regressive || g_eAnimationMode == eAnimationMode_Runner) {
    T_RecordedActionMessage sRecorded;
    sRecorded.actionMessage = eActionMessage_light1OutChannel_off;
    if (!isCheckedOutputMessage(sRecorded.actionMessage)) return;
    recordMessageAction(sRecorded);
  }
}

/** 
 *  light2OutChannel.off action message callback (Action Initiation).
 */
void OUT_light2OutChannel_off()
{
  if (g_eTraceMode == eTrace_Enable) {printf("   ActionMessage: light2OutChannel.off \n\n");}
  if (g_eAnimationMode == eAnimationMode_Regressive || g_eAnimationMode == eAnimationMode_Runner) {
    T_RecordedActionMessage sRecorded;
    sRecorded.actionMessage = eActionMessage_light2OutChannel_off;
    if (!isCheckedOutputMessage(sRecorded.actionMessage)) return;
    recordMessageAction(sRecorded);
  }
}

/** 
 *  light2OutChannel.on action message callback (Action Initiation).
 */
void OUT_light2OutChannel_on()
{
  if (g_eTraceMode == eTrace_Enable) {printf("   ActionMessage: light2OutChannel.on \n\n");}
  if (g_eAnimationMode == eAnimationMode_Regressive || g_eAnimationMode == eAnimationMode_Runner) {
    T_RecordedActionMessage sRecorded;
    sRecorded.actionMessage = eActionMessage_light2OutChannel_on;
    if (!isCheckedOutputMessage(sRecorded.actionMessage)) return;
    recordMessageAction(sRecorded);
  }
}

/** 
 *  driveOutChannel.open action message callback (Action Initiation).
 */
void OUT_driveOutChannel_open()
{
  if (g_eTraceMode == eTrace_Enable) {printf("   ActionMessage: driveOutChannel.open \n\n");}
  if (g_eAnimationMode == eAnimationMode_Regressive || g_eAnimationMode == eAnimationMode_Runner) {
    T_RecordedActionMessage sRecorded;
    sRecorded.actionMessage = eActionMessage_driveOutChannel_open;
    if (!isCheckedOutputMessage(sRecorded.actionMessage)) return;
    recordMessageAction(sRecorded);
  }
}

/** 
 *  driveOutChannel.close action message callback (Action Initiation).
 */
void OUT_driveOutChannel_close()
{
  if (g_eTraceMode == eTrace_Enable) {printf("   ActionMessage: driveOutChannel.close \n\n");}
  if (g_eAnimationMode == eAnimationMode_Regressive || g_eAnimationMode == eAnimationMode_Runner) {
    T_RecordedActionMessage sRecorded;
    sRecorded.actionMessage = eActionMessage_driveOutChannel_close;
    if (!isCheckedOutputMessage(sRecorded.actionMessage)) return;
    recordMessageAction(sRecorded);
  }
}

/** 
 *  driveOutChannel.stop action message callback (Action Initiation).
 */
void OUT_driveOutChannel_stop()
{
  if (g_eTraceMode == eTrace_Enable) {printf("   ActionMessage: driveOutChannel.stop \n\n");}
  if (g_eAnimationMode == eAnimationMode_Regressive || g_eAnimationMode == eAnimationMode_Runner) {
    T_RecordedActionMessage sRecorded;
    sRecorded.actionMessage = eActionMessage_driveOutChannel_stop;
    if (!isCheckedOutputMessage(sRecorded.actionMessage)) return;
    recordMessageAction(sRecorded);
  }
}

/** 
 *  lightBarrierOutChannel.on action message callback (Action Initiation).
 */
void OUT_lightBarrierOutChannel_on()
{
  if (g_eTraceMode == eTrace_Enable) {printf("   ActionMessage: lightBarrierOutChannel.on \n\n");}
  if (g_eAnimationMode == eAnimationMode_Regressive || g_eAnimationMode == eAnimationMode_Runner) {
    T_RecordedActionMessage sRecorded;
    sRecorded.actionMessage = eActionMessage_lightBarrierOutChannel_on;
    if (!isCheckedOutputMessage(sRecorded.actionMessage)) return;
    recordMessageAction(sRecorded);
  }
}

/** 
 *  lightBarrierOutChannel.off action message callback (Action Initiation).
 */
void OUT_lightBarrierOutChannel_off()
{
  if (g_eTraceMode == eTrace_Enable) {printf("   ActionMessage: lightBarrierOutChannel.off \n\n");}
  if (g_eAnimationMode == eAnimationMode_Regressive || g_eAnimationMode == eAnimationMode_Runner) {
    T_RecordedActionMessage sRecorded;
    sRecorded.actionMessage = eActionMessage_lightBarrierOutChannel_off;
    if (!isCheckedOutputMessage(sRecorded.actionMessage)) return;
    recordMessageAction(sRecorded);
  }
}


/** Forward TestCase close_at_beginning */
int testCase_close_at_beginning(int mainTestCase);

/** Forward TestCase open_timeup_close */
int testCase_open_timeup_close(int mainTestCase);

/** Forward TestCase blink_while_closing */
int testCase_blink_while_closing(int mainTestCase);

/** Forward TestCase open_timeup_startClosing */
int testCase_open_timeup_startClosing(int mainTestCase);

/** Forward TestCase open_timeup_close_lightbarrier_interrupt_immediately */
int testCase_open_timeup_close_lightbarrier_interrupt_immediately(int mainTestCase);

/** Forward TestCase alarm_when_blocked */
int testCase_alarm_when_blocked(int mainTestCase);

/** Forward TestCase alarm_while_start_opening */
int testCase_alarm_while_start_opening(int mainTestCase);

/** 
 *  TestCase open
 *  mainTestCase 1 if main test case, 0 if sub test case.
 *  @return 1 if test case ok. 0 if test case failed.
 */
int testCase_open(int mainTestCase)
{
  T_RecordedActionMessage sRecorded;
  
  if (mainTestCase) 
  {
    printf(">>> TestCase open [a838037a-7628-11e4-9ea4-f90149ada069]\n");
    s_nSystemTick = 0;
    if (!fINIT_()) 
    {
      printf("\nInitialization failed\n"); 
      return 0;
    }
  }
  
  activeTestCase = eTestCase_open;
  sendMessageEvent(eEventMessage_button1InChannel_press,1 );
  sRecorded.actionMessage = eActionMessage_driveOutChannel_open;
  if (!assertMessageAction(sRecorded,"TestEvent button1InChannel.press [db39442b-7628-11e4-9ea4-f90149ada069]","[ee5959c8-7628-11e4-9ea4-f90149ada069]", "open" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent button1InChannel.press [db39442b-7628-11e4-9ea4-f90149ada069]", "open")) {return 0;}
  
  sendMessageEvent(eEventMessage_doorInChannel_doorNotClosed,1 );
  if (!assertMessageActionCount("TestEvent doorInChannel.doorNotClosed [fa004abd-7628-11e4-9ea4-f90149ada069]", "open")) {return 0;}
  
  sendMessageEvent(eEventMessage_doorInChannel_doorOpened,1 );
  sRecorded.actionMessage = eActionMessage_driveOutChannel_stop;
  if (!assertMessageAction(sRecorded,"TestEvent doorInChannel.doorOpened [099e8d8b-7629-11e4-9ea4-f90149ada069]","[0f286668-7629-11e4-9ea4-f90149ada069]", "open" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent doorInChannel.doorOpened [099e8d8b-7629-11e4-9ea4-f90149ada069]", "open")) {return 0;}
  

  return 1;
}

/** 
 *  TestCase close_at_beginning
 *  mainTestCase 1 if main test case, 0 if sub test case.
 *  @return 1 if test case ok. 0 if test case failed.
 */
int testCase_close_at_beginning(int mainTestCase)
{
  T_RecordedActionMessage sRecorded;
  
  if (mainTestCase) 
  {
    printf(">>> TestCase close_at_beginning [27fcffe2-5e89-11e4-b28b-9f8038c8c32d]\n");
    s_nSystemTick = 0;
    if (!fINIT_()) 
    {
      printf("\nInitialization failed\n"); 
      return 0;
    }
  }
  
  activeTestCase = eTestCase_close_at_beginning;
  sendMessageEvent(eEventMessage_doorInChannel_doorNotClosed,1 );
  sRecorded.actionMessage = eActionMessage_driveOutChannel_close;
  if (!assertMessageAction(sRecorded,"TestEvent doorInChannel.doorNotClosed [99420a1c-5e89-11e4-b28b-9f8038c8c32d]","[9feb35ae-5e89-11e4-b28b-9f8038c8c32d]", "close_at_beginning" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent doorInChannel.doorNotClosed [99420a1c-5e89-11e4-b28b-9f8038c8c32d]", "close_at_beginning")) {return 0;}
  
  sendMessageEvent(eEventMessage_doorInChannel_doorClosed,1 );
  sRecorded.actionMessage = eActionMessage_driveOutChannel_stop;
  if (!assertMessageAction(sRecorded,"TestEvent doorInChannel.doorClosed [a32360e0-5e8a-11e4-b28b-9f8038c8c32d]","[a32360e1-5e8a-11e4-b28b-9f8038c8c32d]", "close_at_beginning" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent doorInChannel.doorClosed [a32360e0-5e8a-11e4-b28b-9f8038c8c32d]", "close_at_beginning")) {return 0;}
  

  return 1;
}

/** 
 *  TestCase open_timeup_close
 *  mainTestCase 1 if main test case, 0 if sub test case.
 *  @return 1 if test case ok. 0 if test case failed.
 */
int testCase_open_timeup_close(int mainTestCase)
{
  T_RecordedActionMessage sRecorded;
  
  if (mainTestCase) 
  {
    printf(">>> TestCase open_timeup_close [a0f08406-4d40-11e4-9197-0359679bc414]\n");
    s_nSystemTick = 0;
    if (!fINIT_()) 
    {
      printf("\nInitialization failed\n"); 
      return 0;
    }
  }
  
  activeTestCase = eTestCase_open_timeup_close;
  sendMessageEvent(eEventMessage_button1InChannel_press,1 );
  sRecorded.actionMessage = eActionMessage_driveOutChannel_open;
  if (!assertMessageAction(sRecorded,"TestEvent button1InChannel.press [3e438540-4d42-11e4-9197-0359679bc414]","[ace709b4-4d42-11e4-9197-0359679bc414]", "open_timeup_close" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent button1InChannel.press [3e438540-4d42-11e4-9197-0359679bc414]", "open_timeup_close")) {return 0;}
  
  sendMessageEvent(eEventMessage_doorInChannel_doorNotClosed,1 );
  if (!assertMessageActionCount("TestEvent doorInChannel.doorNotClosed [9277808d-5fb2-11e4-a8da-0534f2773881]", "open_timeup_close")) {return 0;}
  
  sendMessageEvent(eEventMessage_button1InChannel_release,1 );
  if (!assertMessageActionCount("TestEvent button1InChannel.release [23cf4a8e-70b0-11e4-99ab-454e858e60a3]", "open_timeup_close")) {return 0;}
  
  sendMessageEvent(eEventMessage_doorInChannel_doorOpened,1 );
  sRecorded.actionMessage = eActionMessage_driveOutChannel_stop;
  if (!assertMessageAction(sRecorded,"TestEvent doorInChannel.doorOpened [944229ab-5de7-11e4-b3d8-533ac356fef7]","[bebec7f1-5de7-11e4-b3d8-533ac356fef7]", "open_timeup_close" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent doorInChannel.doorOpened [944229ab-5de7-11e4-b3d8-533ac356fef7]", "open_timeup_close")) {return 0;}
  
  sendMessageEvent(eEventMessage_lightBarrierInChannel_cleared,1 );
  if (!assertMessageActionCount("TestEvent lightBarrierInChannel.cleared [7a14647c-70ac-11e4-99ab-454e858e60a3]", "open_timeup_close")) {return 0;}
  
  sendTickEvent(20,1);
  sRecorded.actionMessage = eActionMessage_driveOutChannel_close;
  if (!assertMessageAction(sRecorded,"TestEvent TICK_ [584cb57d-5dea-11e4-b3d8-533ac356fef7]","[987e1ea2-5dea-11e4-b3d8-533ac356fef7]", "open_timeup_close" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent TICK_ [584cb57d-5dea-11e4-b3d8-533ac356fef7]", "open_timeup_close")) {return 0;}
  
  sendMessageEvent(eEventMessage_doorInChannel_doorNotOpened,1 );
  if (!assertMessageActionCount("TestEvent doorInChannel.doorNotOpened [cea5e137-70b0-11e4-99ab-454e858e60a3]", "open_timeup_close")) {return 0;}
  
  sendMessageEvent(eEventMessage_doorInChannel_doorClosed,1 );
  sRecorded.actionMessage = eActionMessage_driveOutChannel_stop;
  if (!assertMessageAction(sRecorded,"TestEvent doorInChannel.doorClosed [33944416-5deb-11e4-b3d8-533ac356fef7]","[3b6b684f-5deb-11e4-b3d8-533ac356fef7]", "open_timeup_close" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent doorInChannel.doorClosed [33944416-5deb-11e4-b3d8-533ac356fef7]", "open_timeup_close")) {return 0;}
  

  return 1;
}

/** 
 *  TestCase blink_while_closing
 *  mainTestCase 1 if main test case, 0 if sub test case.
 *  @return 1 if test case ok. 0 if test case failed.
 */
int testCase_blink_while_closing(int mainTestCase)
{
  T_RecordedActionMessage sRecorded;
  
  if (mainTestCase) 
  {
    printf(">>> TestCase blink_while_closing [070d74a7-70a3-11e4-99ab-454e858e60a3]\n");
    s_nSystemTick = 0;
    if (!fINIT_()) 
    {
      printf("\nInitialization failed\n"); 
      return 0;
    }
  }
  
  activeTestCase = eTestCase_blink_while_closing;
  sendMessageEvent(eEventMessage_doorInChannel_doorNotClosed,1 );
  sRecorded.actionMessage = eActionMessage_light1OutChannel_on;
  if (!assertMessageAction(sRecorded,"TestEvent doorInChannel.doorNotClosed [070d74aa-70a3-11e4-99ab-454e858e60a3]","[070d74a9-70a3-11e4-99ab-454e858e60a3]", "blink_while_closing" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent doorInChannel.doorNotClosed [070d74aa-70a3-11e4-99ab-454e858e60a3]", "blink_while_closing")) {return 0;}
  
  sendTickEvent(5,1);
  sRecorded.actionMessage = eActionMessage_light1OutChannel_off;
  if (!assertMessageAction(sRecorded,"TestEvent TICK_ [b6a31a27-70a3-11e4-99ab-454e858e60a3]","[bd1c8310-70a3-11e4-99ab-454e858e60a3]", "blink_while_closing" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent TICK_ [b6a31a27-70a3-11e4-99ab-454e858e60a3]", "blink_while_closing")) {return 0;}
  
  sendTickEvent(5,1);
  sRecorded.actionMessage = eActionMessage_light1OutChannel_on;
  if (!assertMessageAction(sRecorded,"TestEvent TICK_ [c1a31cb9-70a3-11e4-99ab-454e858e60a3]","[c1a31cba-70a3-11e4-99ab-454e858e60a3]", "blink_while_closing" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent TICK_ [c1a31cb9-70a3-11e4-99ab-454e858e60a3]", "blink_while_closing")) {return 0;}
  

  return 1;
}

/** 
 *  TestCase open_timeup_startClosing
 *  mainTestCase 1 if main test case, 0 if sub test case.
 *  @return 1 if test case ok. 0 if test case failed.
 */
int testCase_open_timeup_startClosing(int mainTestCase)
{
  T_RecordedActionMessage sRecorded;
  
  if (mainTestCase) 
  {
    printf(">>> TestCase open_timeup_startClosing [a71105a3-70a6-11e4-99ab-454e858e60a3]\n");
    s_nSystemTick = 0;
    if (!fINIT_()) 
    {
      printf("\nInitialization failed\n"); 
      return 0;
    }
  }
  
  activeTestCase = eTestCase_open_timeup_startClosing;
  sendMessageEvent(eEventMessage_button1InChannel_press,1 );
  sRecorded.actionMessage = eActionMessage_driveOutChannel_open;
  if (!assertMessageAction(sRecorded,"TestEvent button1InChannel.press [a71105a6-70a6-11e4-99ab-454e858e60a3]","[a71105a5-70a6-11e4-99ab-454e858e60a3]", "open_timeup_startClosing" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent button1InChannel.press [a71105a6-70a6-11e4-99ab-454e858e60a3]", "open_timeup_startClosing")) {return 0;}
  
  sendMessageEvent(eEventMessage_button1InChannel_release,1 );
  if (!assertMessageActionCount("TestEvent button1InChannel.release [61d13425-70b1-11e4-99ab-454e858e60a3]", "open_timeup_startClosing")) {return 0;}
  
  sendMessageEvent(eEventMessage_doorInChannel_doorNotClosed,1 );
  if (!assertMessageActionCount("TestEvent doorInChannel.doorNotClosed [a71105a8-70a6-11e4-99ab-454e858e60a3]", "open_timeup_startClosing")) {return 0;}
  
  sendMessageEvent(eEventMessage_doorInChannel_doorOpened,1 );
  sRecorded.actionMessage = eActionMessage_driveOutChannel_stop;
  if (!assertMessageAction(sRecorded,"TestEvent doorInChannel.doorOpened [a71105ab-70a6-11e4-99ab-454e858e60a3]","[a71105aa-70a6-11e4-99ab-454e858e60a3]", "open_timeup_startClosing" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent doorInChannel.doorOpened [a71105ab-70a6-11e4-99ab-454e858e60a3]", "open_timeup_startClosing")) {return 0;}
  
  sendMessageEvent(eEventMessage_lightBarrierInChannel_cleared,1 );
  if (!assertMessageActionCount("TestEvent lightBarrierInChannel.cleared [a1dfb6b6-70b2-11e4-99ab-454e858e60a3]", "open_timeup_startClosing")) {return 0;}
  
  sendTickEvent(20,1);
  sRecorded.actionMessage = eActionMessage_driveOutChannel_close;
  if (!assertMessageAction(sRecorded,"TestEvent TICK_ [a71105ad-70a6-11e4-99ab-454e858e60a3]","[a71105ac-70a6-11e4-99ab-454e858e60a3]", "open_timeup_startClosing" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent TICK_ [a71105ad-70a6-11e4-99ab-454e858e60a3]", "open_timeup_startClosing")) {return 0;}
  

  return 1;
}

/** 
 *  TestCase open_timeup_close_lightbarrier_interrupt_immediately
 *  mainTestCase 1 if main test case, 0 if sub test case.
 *  @return 1 if test case ok. 0 if test case failed.
 */
int testCase_open_timeup_close_lightbarrier_interrupt_immediately(int mainTestCase)
{
  T_RecordedActionMessage sRecorded;
  
  if (mainTestCase) 
  {
    printf(">>> TestCase open_timeup_close_lightbarrier_interrupt_immediately [d6f58774-70a4-11e4-99ab-454e858e60a3]\n");
    s_nSystemTick = 0;
    if (!fINIT_()) 
    {
      printf("\nInitialization failed\n"); 
      return 0;
    }
  }
  
  if (!testCase_open_timeup_startClosing(0)) return 0;
  activeTestCase = eTestCase_open_timeup_close_lightbarrier_interrupt_immediately;
  sendMessageEvent(eEventMessage_lightBarrierInChannel_interrupted,1 );
  if (!assertMessageActionCount("TestEvent lightBarrierInChannel.interrupted [d6f58777-70a4-11e4-99ab-454e858e60a3]", "open_timeup_close_lightbarrier_interrupt_immediately")) {return 0;}
  
  sendMessageEvent(eEventMessage_doorInChannel_doorNotOpened,1 );
  sRecorded.actionMessage = eActionMessage_driveOutChannel_open;
  if (!assertMessageAction(sRecorded,"TestEvent doorInChannel.doorNotOpened [d6f58779-70a4-11e4-99ab-454e858e60a3]","[36d14149-70a7-11e4-99ab-454e858e60a3]", "open_timeup_close_lightbarrier_interrupt_immediately" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent doorInChannel.doorNotOpened [d6f58779-70a4-11e4-99ab-454e858e60a3]", "open_timeup_close_lightbarrier_interrupt_immediately")) {return 0;}
  
  sendMessageEvent(eEventMessage_doorInChannel_doorOpened,1 );
  sRecorded.actionMessage = eActionMessage_driveOutChannel_stop;
  if (!assertMessageAction(sRecorded,"TestEvent doorInChannel.doorOpened [d6f5877c-70a4-11e4-99ab-454e858e60a3]","[d6f5877b-70a4-11e4-99ab-454e858e60a3]", "open_timeup_close_lightbarrier_interrupt_immediately" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent doorInChannel.doorOpened [d6f5877c-70a4-11e4-99ab-454e858e60a3]", "open_timeup_close_lightbarrier_interrupt_immediately")) {return 0;}
  

  return 1;
}

/** 
 *  TestCase alarm_when_blocked
 *  mainTestCase 1 if main test case, 0 if sub test case.
 *  @return 1 if test case ok. 0 if test case failed.
 */
int testCase_alarm_when_blocked(int mainTestCase)
{
  T_RecordedActionMessage sRecorded;
  
  if (mainTestCase) 
  {
    printf(">>> TestCase alarm_when_blocked [60d7ebc9-7628-11e4-9ea4-f90149ada069]\n");
    s_nSystemTick = 0;
    if (!fINIT_()) 
    {
      printf("\nInitialization failed\n"); 
      return 0;
    }
  }
  
  if (!testCase_open(0)) return 0;
  activeTestCase = eTestCase_alarm_when_blocked;
  sendMessageEvent(eEventMessage_button2InChannel_press,1 );
  sRecorded.actionMessage = eActionMessage_driveOutChannel_close;
  if (!assertMessageAction(sRecorded,"TestEvent button2InChannel.press [e9013816-762b-11e4-9ea4-f90149ada069]","[f679dba8-762b-11e4-9ea4-f90149ada069]", "alarm_when_blocked" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent button2InChannel.press [e9013816-762b-11e4-9ea4-f90149ada069]", "alarm_when_blocked")) {return 0;}
  
  sendMessageEvent(eEventMessage_doorInChannel_doorNotOpened,1 );
  if (!assertMessageActionCount("TestEvent doorInChannel.doorNotOpened [96467e4c-762f-11e4-9ea4-f90149ada069]", "alarm_when_blocked")) {return 0;}
  
  sendMessageEvent(eEventMessage_doorInChannel_doorClosed,1 );
  sRecorded.actionMessage = eActionMessage_driveOutChannel_stop;
  if (!assertMessageAction(sRecorded,"TestEvent doorInChannel.doorClosed [e7d3f0df-762d-11e4-9ea4-f90149ada069]","[f0631a81-762d-11e4-9ea4-f90149ada069]", "alarm_when_blocked" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent doorInChannel.doorClosed [e7d3f0df-762d-11e4-9ea4-f90149ada069]", "alarm_when_blocked")) {return 0;}
  
  sendMessageEvent(eEventMessage_button2InChannel_release,1 );
  if (!assertMessageActionCount("TestEvent button2InChannel.release [f5c5953a-762d-11e4-9ea4-f90149ada069]", "alarm_when_blocked")) {return 0;}
  

  return 1;
}

/** 
 *  TestCase alarm_while_start_opening
 *  mainTestCase 1 if main test case, 0 if sub test case.
 *  @return 1 if test case ok. 0 if test case failed.
 */
int testCase_alarm_while_start_opening(int mainTestCase)
{
  T_RecordedActionMessage sRecorded;
  
  if (mainTestCase) 
  {
    printf(">>> TestCase alarm_while_start_opening [43bb5355-763d-11e4-9ea4-f90149ada069]\n");
    s_nSystemTick = 0;
    if (!fINIT_()) 
    {
      printf("\nInitialization failed\n"); 
      return 0;
    }
  }
  
  activeTestCase = eTestCase_alarm_while_start_opening;
  sendMessageEvent(eEventMessage_button1InChannel_press,1 );
  sRecorded.actionMessage = eActionMessage_driveOutChannel_open;
  if (!assertMessageAction(sRecorded,"TestEvent button1InChannel.press [6b054ea0-763d-11e4-9ea4-f90149ada069]","[736d8f49-763d-11e4-9ea4-f90149ada069]", "alarm_while_start_opening" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent button1InChannel.press [6b054ea0-763d-11e4-9ea4-f90149ada069]", "alarm_while_start_opening")) {return 0;}
  
  sendMessageEvent(eEventMessage_button2InChannel_press,1 );
  if (!assertMessageActionCount("TestEvent button2InChannel.press [7bcb2196-763d-11e4-9ea4-f90149ada069]", "alarm_while_start_opening")) {return 0;}
  
  sendMessageEvent(eEventMessage_doorInChannel_doorNotClosed,1 );
  sRecorded.actionMessage = eActionMessage_driveOutChannel_close;
  if (!assertMessageAction(sRecorded,"TestEvent doorInChannel.doorNotClosed [9d34e766-763d-11e4-9ea4-f90149ada069]","[afc8c392-763d-11e4-9ea4-f90149ada069]", "alarm_while_start_opening" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent doorInChannel.doorNotClosed [9d34e766-763d-11e4-9ea4-f90149ada069]", "alarm_while_start_opening")) {return 0;}
  
  sendMessageEvent(eEventMessage_doorInChannel_doorClosed,1 );
  sRecorded.actionMessage = eActionMessage_driveOutChannel_stop;
  if (!assertMessageAction(sRecorded,"TestEvent doorInChannel.doorClosed [acbda66e-763d-11e4-9ea4-f90149ada069]","[c7d364cd-763d-11e4-9ea4-f90149ada069]", "alarm_while_start_opening" ,0)) {return 0;}
  if (!assertMessageActionCount("TestEvent doorInChannel.doorClosed [acbda66e-763d-11e4-9ea4-f90149ada069]", "alarm_while_start_opening")) {return 0;}
  

  return 1;
}

/** 
 *  Regressive animation, controlled by test cases. 
 *  @return The number of failed test cases.
 */
int regressiveAnimation()
{
  printf("TESTING: CipTestSuite testsuite [3891007e-4d40-11e4-9197-0359679bc414]\n\n"); 
  g_eAnimationMode = eAnimationMode_Regressive;
  int nSuceededTestCases = 0;
  int nFailedTestCases = 0;
  g_eTraceMode = eTrace_Disable;
  if (testCase_close_at_beginning(1)) {++nSuceededTestCases;} else {++nFailedTestCases;}
  g_eTraceMode = eTrace_Disable;
  if (testCase_open_timeup_close(1)) {++nSuceededTestCases;} else {++nFailedTestCases;}
  g_eTraceMode = eTrace_Disable;
  if (testCase_blink_while_closing(1)) {++nSuceededTestCases;} else {++nFailedTestCases;}
  g_eTraceMode = eTrace_Disable;
  if (testCase_open_timeup_startClosing(1)) {++nSuceededTestCases;} else {++nFailedTestCases;}
  g_eTraceMode = eTrace_Enable;
  if (testCase_open_timeup_close_lightbarrier_interrupt_immediately(1)) {++nSuceededTestCases;} else {++nFailedTestCases;}
  g_eTraceMode = eTrace_Enable;
  if (testCase_alarm_when_blocked(1)) {++nSuceededTestCases;} else {++nFailedTestCases;}
  g_eTraceMode = eTrace_Disable;
  if (testCase_alarm_while_start_opening(1)) {++nSuceededTestCases;} else {++nFailedTestCases;}
  printf("\n> SUMMARY: %i Test Case(s) Executed.\n",nSuceededTestCases+nFailedTestCases); 
  if (nFailedTestCases) {printf("> WARNING: %i Test Case(s) Failed.\n",nFailedTestCases);} 
  return nFailedTestCases;
}

/** 
 *  C/C++ Unit gtest, controlled by test cases. 
 *  @return The number of failed test cases.
 */
int runnerAnimation()
{
  int nSuceededTestCases = 0;
  int nFailedTestCases = 0;
  g_eAnimationMode = eAnimationMode_Runner;
	  
  printf("[==========] Running 7 test from 1 test case.\n");
  printf("[----------] Global test environment set-up.\n");
  printf("[----------] 7 test from testsuite\n");
       	  
  /* close_at_beginning */
  g_eTraceMode = eTrace_Disable;
  printf("[ RUN      ] testsuite.close_at_beginning\n");
  if (testCase_close_at_beginning(1)) {
  	printf("[       OK ] testsuite.close_at_beginning (%i ms)\n",s_nSystemTick);
  	++nSuceededTestCases;
  } else {
  	++nFailedTestCases;
	printf("[  FAILED  ] testsuite.close_at_beginning (%i ms)\n",s_nSystemTick);
  }
	
  /* open_timeup_close */
  g_eTraceMode = eTrace_Disable;
  printf("[ RUN      ] testsuite.open_timeup_close\n");
  if (testCase_open_timeup_close(1)) {
  	printf("[       OK ] testsuite.open_timeup_close (%i ms)\n",s_nSystemTick);
  	++nSuceededTestCases;
  } else {
  	++nFailedTestCases;
	printf("[  FAILED  ] testsuite.open_timeup_close (%i ms)\n",s_nSystemTick);
  }
	
  /* blink_while_closing */
  g_eTraceMode = eTrace_Disable;
  printf("[ RUN      ] testsuite.blink_while_closing\n");
  if (testCase_blink_while_closing(1)) {
  	printf("[       OK ] testsuite.blink_while_closing (%i ms)\n",s_nSystemTick);
  	++nSuceededTestCases;
  } else {
  	++nFailedTestCases;
	printf("[  FAILED  ] testsuite.blink_while_closing (%i ms)\n",s_nSystemTick);
  }
	
  /* open_timeup_startClosing */
  g_eTraceMode = eTrace_Disable;
  printf("[ RUN      ] testsuite.open_timeup_startClosing\n");
  if (testCase_open_timeup_startClosing(1)) {
  	printf("[       OK ] testsuite.open_timeup_startClosing (%i ms)\n",s_nSystemTick);
  	++nSuceededTestCases;
  } else {
  	++nFailedTestCases;
	printf("[  FAILED  ] testsuite.open_timeup_startClosing (%i ms)\n",s_nSystemTick);
  }
	
  /* open_timeup_close_lightbarrier_interrupt_immediately */
  g_eTraceMode = eTrace_Enable;
  printf("[ RUN      ] testsuite.open_timeup_close_lightbarrier_interrupt_immediately\n");
  if (testCase_open_timeup_close_lightbarrier_interrupt_immediately(1)) {
  	printf("[       OK ] testsuite.open_timeup_close_lightbarrier_interrupt_immediately (%i ms)\n",s_nSystemTick);
  	++nSuceededTestCases;
  } else {
  	++nFailedTestCases;
	printf("[  FAILED  ] testsuite.open_timeup_close_lightbarrier_interrupt_immediately (%i ms)\n",s_nSystemTick);
  }
	
  /* alarm_when_blocked */
  g_eTraceMode = eTrace_Enable;
  printf("[ RUN      ] testsuite.alarm_when_blocked\n");
  if (testCase_alarm_when_blocked(1)) {
  	printf("[       OK ] testsuite.alarm_when_blocked (%i ms)\n",s_nSystemTick);
  	++nSuceededTestCases;
  } else {
  	++nFailedTestCases;
	printf("[  FAILED  ] testsuite.alarm_when_blocked (%i ms)\n",s_nSystemTick);
  }
	
  /* alarm_while_start_opening */
  g_eTraceMode = eTrace_Disable;
  printf("[ RUN      ] testsuite.alarm_while_start_opening\n");
  if (testCase_alarm_while_start_opening(1)) {
  	printf("[       OK ] testsuite.alarm_while_start_opening (%i ms)\n",s_nSystemTick);
  	++nSuceededTestCases;
  } else {
  	++nFailedTestCases;
	printf("[  FAILED  ] testsuite.alarm_while_start_opening (%i ms)\n",s_nSystemTick);
  }
	
  printf("[----------] 7 test from testsuite (0 ms total)\n");
  printf("\n> SUMMARY: %i Test Case(s) Executed.\n",nSuceededTestCases+nFailedTestCases); 
  if (nFailedTestCases) {
  	printf("> WARNING: %i Test Case(s) Failed.\n",nFailedTestCases);
  }
  printf("[----------] Global test environment tear-down\n");
  printf("[==========] 7 test from 1 test case ran. (0 ms total)\n");
  return nFailedTestCases;
}

/** 
 *  Manual animation, controlled by keyboard input. 
 *  @return 0 if exited normally. 1 otherwise.
 */
int manualAnimation()
{
  g_eAnimationMode = eAnimationMode_Manual;
  g_eTraceMode = eTrace_Enable;
  
  if (!fINIT_()) 
  {
    printf("\nInitialization failed\n");
    return 1;
  }
  
  while (1) 
  {
    printf("------------------------------------\n");
    printf("Enter -1 (Quit)\n");
    printf("Enter  0 (TICK_ & TIMEUP_)\n");
    printf("Enter  %i (button1InChannel: press)\n",eEventMessage_button1InChannel_press);
    printf("Enter  %i (button1InChannel: release)\n",eEventMessage_button1InChannel_release);
    printf("Enter  %i (button2InChannel: press)\n",eEventMessage_button2InChannel_press);
    printf("Enter  %i (button2InChannel: release)\n",eEventMessage_button2InChannel_release);
    printf("Enter  %i (doorInChannel: doorOpened)\n",eEventMessage_doorInChannel_doorOpened);
    printf("Enter  %i (doorInChannel: doorClosed)\n",eEventMessage_doorInChannel_doorClosed);
    printf("Enter  %i (doorInChannel: doorNotClosed)\n",eEventMessage_doorInChannel_doorNotClosed);
    printf("Enter  %i (doorInChannel: doorNotOpened)\n",eEventMessage_doorInChannel_doorNotOpened);
    printf("Enter  %i (lightBarrierInChannel: interrupted)\n",eEventMessage_lightBarrierInChannel_interrupted);
    printf("Enter  %i (lightBarrierInChannel: cleared)\n",eEventMessage_lightBarrierInChannel_cleared);
    printf("------------------------------------\n");

    T_EEventMessage eEventMessage;
    scanf("%i", (int*)&eEventMessage);
    if (eEventMessage == eEventMessage_Quit) {break;}
    else if (eEventMessage == eEventMessage_Tick) {sendTickEvent(1,1);}
    else if (!sendMessageEvent(eEventMessage, 1)) {printf("\n Invalid Input: %i\n\n",eEventMessage);}
  }
  return 0;
}




/** 
 *  Displays an info text for this program.
 *  @param i_pcProgramName The name of the program file.
 */
void displayInfoText(char* i_pcProgramName)
{
  printf("Usage: %s [option]\n",i_pcProgramName);
  printf(" [option]\n");
  printf(" - manual:     Manual animation, controlled by keyboard input.\n");
  printf(" - regressive: Regressive animation, controlled by test cases.\n");
  printf(" - runner: C/C++ Unit gtest.\n");
}

/**
 *  Main program for animation.
 *  @param @argc The number of arguments passed to the program.
 *  @param @argv The arguments passed to the program.
 *  @return 0 if exited normally. 1 otherwise.
 */
int main(int argc, char *argv[]) 
{
  int ret;
  if (argc == 1) 
  {
    displayInfoText(argv[0]);
    return 1;
  }
  if (strcmp(argv[1],"manual")==0) 
  {
    ret = manualAnimation()?1:0;
    return ret;
  }
  if (strcmp(argv[1],"regressive")==0) 
  {
    ret = regressiveAnimation()?1:0;
    return ret;
  }
  if (strcmp(argv[1],"runner")==0) 
  {
    ret = runnerAnimation()?1:0;
    return ret;
  }
  displayInfoText(argv[0]);
  return 1;
}

/* Actifsource ID=[bc0af8c6-407d-11e2-9941-ff65f3a86106,3891007e-4d40-11e4-9197-0359679bc414,6sZ5474s5tSdw0rX/fpLdN1dUZQ=] */
